\chapter{Multiple sequence alignment}

Sequence alignment, in general, is a task whose purpose is to arrange two or more sequences with a common alphabet to identify similar
and different regions within them. A set of sequences being \emph{aligned} in this case can be understood as each being extended by spaces
in such a way that if they are arranged in a matrix, each sequence occupying one row and each column containing one character, it can be seen
what had to happen for one sequence to change into another on a character-by-character basis: insertion (or deletion), character substitution,
or nothing if the characters in the given position are identical. A good sequence alignment algorithm is one that does not perform
unnecessary insertions (deletions) or substitutions.

The problem of multiple sequence alignment is most studied in bioinformatics. Since DNA was first sequenced
in the 1970s, there has been a need to compare various genomes to determine similarity. As organisms mutate and evolve, their
DNA or RNA changes. Aligning their genomes reveals similar and different regions, which facilitates the tracking of these
mutations and makes it possible to determine the order in which they happened.

However, the applications of sequence alignment are not limited to biology. Every task that makes use of determinig the similarity
of some sequences, where the emphasis is put on finding regions where they do not diverge, can make use of the existing methods.

Melody alignment of Gregorian chant can be considered as such. As the tradition spread across Europe, each place changed some of 
the existing melodies by a little, thereby creating new melodies that can change further as they travel through time and space.
This is akin to the mutations in DNA caused by environmental factors. Finding well-conserved regions in many instances of chant
provides great insight into which parts of a melody are unlikely to change, and, on the other hand, which ones tend to vary
a lot. It can also reveal the ancestors of a melody and the path which it traveled to transform into its final form.
This is in line with the focus of philology shifting not to merely reconstructing an earliest layer of a text (with the unspoken 
assumption that this is the ``real'' text), but to map the entire tradition of text transmission and evolution, taking the later layers 
to be as valid within their cultural environment as the older layers.


In this chapter, we will first give the definition of the problem of sequence alignment. We will mention some important considerations,
as well as theoretical limitations. Then we will provide an overview of the methods developed for bioinformatics that attempt to solve
the problem. Finally, we will show how we applied the existing methods and technologies on Gregorian chant melodies, as encoded
using Volpiano in current chant databases.

\section{The problem of sequence alignment}

Assume that we have an alphabet $\mathcal{A}$ and a character $\sigma$ such that $\sigma \notin \mathcal{A}$. Then let us have a set
of sequences $S = \{s_1, s_2, \dots, s_k\}$ with $s_i \in \mathcal{A}^{l_i}$. The output of a sequence alignment algorithm is the set of
aligned sequences $A = \{a_1, a_2, \dots, a_k\}$, where $a_k \in (\mathcal{A}\cup\{\sigma\})^L$, $L \geq l_i \:\forall i\in\{1, 2, \dots, k\}$.
Each original sequence $s_i$ can be obtained from the aligned sequence $a_i$ by removing all $\sigma$.

Given two aligned sequences $a_i$ and $a_j$ and an index $p \leq L$, we define the following operations:

\begin{itemize}
    \item \emph{Identity}: $(a_i)_k = (a_j)_k$
    \item \emph{Insertion}: $(a_i)_k = \sigma \land (a_j)_k \in \mathcal{A}$
    \item \emph{Deletion}: $(a_i)_k \in \mathcal{A} \land (a_j)_k = \sigma$
    \item \emph{Substitution}: $(a_i)_k \in \mathcal{A} \land (a_j)_k \in \mathcal{A} \land (a_i)_k \neq (a_j)_k$
\end{itemize}

Each of the operations has an associated cost. The cost of substitution can further vary depending on which characters are being
substituted. We can then define the overall cost of the alignment $A$ in different ways, e.g. as the sum of costs over all triples
$(i, j, p) \: \forall i, j \in \{1, 2, \dots, k\} \: \forall p \leq L$ or as the sum of costs for unordered pairs $\{i, j\}$ and indices $p$,
in which case insertion and deletion are considered the same operation. The goal of a sequence alignment algorithm is to minimize the cost.
There are other, more complicated ways of defining the cost  function, and the performance of an algorithm is highly dependent on which one it uses.

\subsection{Pairwise and multiple sequence alignment}

Depending on the number of sequences to align, we distinguish between pairwise alignment for pairs of sequences and multiple sequence alignment
for more than two. Despite the similarity in their outcomes, the two problems are fundamentally different from a computational perspective.

Pairwise alignment is relatively easy to solve. The Needleman-Wunsch algorithm, which is a dynamic programming algorithm, can find an optimal
solution in the asymptotic time of $\mathcal{O}(mn)$, where $m$ and $n$ are the respective lengths of the sequences. This means that it is
possible to find an optimal alignment even for longer sequences.

Needleman-Wunsch algorithm can be extended to more than two sequences. However, with each additional sequence, its complexity increases,
and it quickly becomes impractical or even practically impossible to align multiple sequences this way. In fact, it has been proven that multiple sequence
alignment is an NP-complete problem \citep{msa_complexity}. It is therefore necessary to use various heuristics to generate alignments. Current
algorithms do not aim at finding the optimal alignment; instead, they try to produce one that is good enough.

\subsection{Local and global sequence alignment}

There is a distinction to be made between local and global sequence alignment.

The problem description above is the definition of global alignment. Aligning sequences globally means aligning the entire sequences end-to-end.
(This does not mean, however, that there cannot be gaps at the beginning or at the end of the generated alignment.)
All characters from all sequences must be present in the final alignment. Global alignment is used to compare relatively similar
sequences, such as protein homologues or versions of the same chant sung at different points in time.

On the other hand, the goal of local alignment is to find similar regions in divergent sequences, while the rest of the sequences is disregarded.
The output of local alignment algorithms contains only a substring of both sequences. Local alignment is suitable for finding conserved patterns.

Both methods are useful in their own way. Local alignment provides a slightly different insight than global alignment, however, they can
be combined to extract more information. In fact, the best current multiple sequence alignment algorithms use local alignment for pairs
of sequences to generate a better overall global alignment. \citep{msa_overview}

\section{Sequence alignment methods}

The methods used to find sequence alignments depend on how many sequences there are and whether they should be aligned globally or locally.
Dynamic programming can used for finding pairwise alignment, both local and global. For many sequences, other methods have been developed. They
do not compute the optimal alignment, however, by using appropriate heuristics, their output is good enough.

\subsection{Pairwise alignment: dynamic programming}

Dynamic programming techniques are useful for pairwise alignment. The Needle\-man-Wunsch algorithm \citep{needleman} computes the global alignment
of two sequences. A variation of the algorithm, the Smith-Waterman algorithm \citep{smith_waterman}, computes the local alignment of two sequences.

\subsubsection{Needleman-Wunsch algorithm}

\emph{This section is based on \cite{needleman}.}

The idea of the algorithm is to start with two empty sequences and subsequently add characters from either or both of the given sequences so as
to obtain an optimal alignment in each step. Namely, suppose that we have two sequence prefixes $A$ and $B$ that have already been aligned optimally
and their alignment gives a score of $s$. Furthermore, suppose that the next characters in the sequences are $a$ and $b$, respectively. There are
three possibilities:

\begin{itemize}
    \item We append $a$ and $b$ to the respective prefixes. By doing so, we obtain the aligned sequence prefixes $Aa$ and $Bb$.
        \begin{verbatim}
            Aa
            Bb
        \end{verbatim}
    \item We append $a$ to $A$ and a gap to $B$. This way, we get the aligned prefixes $Aa$ and $B$.
        \begin{verbatim}
            Aa
            B-
        \end{verbatim}
    \item We append a gap to $A$ and $b$ to $B$. Now we have aligned the prefixes $A$ and $Bb$.
        \begin{verbatim}
            A-
            Bb
        \end{verbatim}
\end{itemize}

Each of the possibilities adds a value to the score $s$ depending on what characters were added. To get the optimal alignment, we choose the one
that yields the highest score. We then proceed to the next character, having two optimally aligned prefixes $A'$ and $B'$. This leads to a recursive
algorithm that can be formulated using dynamic programming.

Let us have two input sequences, $A$ and $B$ of lengths $m$ and $n$ with a common alphabet $\mathcal{A}$ and the gap character $\sigma$.
Let us define the scoring function $s$ as

\[ s(a, b) = 
    \begin{cases}
        1  & \text{if } a = b \\
        -1 & \text{if } a = \sigma \lor b = \sigma \\
        -1 & \text{if }  a \neq b
    \end{cases}
\]

The algorithm initializes a matrix $M$ of size $(m+1) * (n+1)$. The rows and columns represent the characters of $A$ and $B$, respectively, except
for the first row and the first column, which represent the beginning of a sequence or an empty sequence. That is to say, the row $M_{i, *}$ represents the
character $A_{i-1}$ for $i \geq 2$ and analogically, the column $M_{*, j}$ represents the character $B_{j-1}$ for $j \geq 2$.

The algorithm iterates over the rows and columns of the matrix. In each step, it calculates the value of a cell $M_{i,j}$, provided that each of the cells $M_{i-1, j}$,
$M_{i, j-1}$ and $M_{i-1, j-1}$ have been filled out, as

\[ M_{i, j} = max
    \begin{cases}
        M_{i-1, j-1} + s(A_{i-1}, B_{j-1}) \\
        M_{i-1, j} + s(A_{i-1}, \sigma)    \\
        M_{i, j-1} + s(\sigma, B_{j-1})
    \end{cases}
\]

In other words, the algorithm either aligns the two characters in positions $i-1$ and $j-1$, or it inserts a gap into sequence $B$, or it inserts a gap into sequence $A$,
and chooses the version which yields the highest score.

The first row and column are apparently special cases, as there is no previous row or column. Therefore, for each cell in the first row or column, there is
only one possible choice of score, which is equivalent to inserting a space.

After filling out the entire matrix, the algorithm then finds the optimal alignment by backtracking in the matrix. It starts in the bottom right
cell of the matrix, which represents both sequences being aligned. In each iteration, it looks at the cells above, to the left and to the top-left
of the current positions and chooses the highest score. If it moves top or left, it means that a gap was inserted. Moving diagonally represents a match
or mismatch. By tracing its way back to the top left corner, the algorithm finds the alignment that yielded the highest score.

Let us show the algorithm on an example. Consider two sequences of nucleotide residues:

\begin{verbatim}
    GATTA
    GCATG
\end{verbatim}

The matrix is initialized without anything filled out.

\begin{verbatim}
          G  C  A  T  G
      
    G 
    A 
    T 
    T 
    A 
\end{verbatim}

We start filling out the matrix in the top left corner. Using the basic scoring scheme (+1 for a match, -1 for everything else), we insert a 0
to the beginning, and, since there is no top cell for the first row and no left cell for the first column, we add -1 to each subsequent cell,
representing a gap insertion.

\begin{verbatim}
          G  C  A  T  G
       0 -1 -2 -3 -4 -5
    G -1
    A -2
    T -3
    T -4
    A -5
\end{verbatim}

The next cell to fill out is the one in the first \verb|G| column and the first \verb|G| row. We have three options:

\begin{itemize}
    \item Move from the top, represents gap insertion for a score of -1. The final score would be $(-1) + (-1) = -2$.
    \item Move diagonally, represents match, giving a score of +1. The score in this case would be $0 + 1 = 1$.
    \item Move from the left, i.e. gap insertion. The score would be $-2$ as in the first case.
\end{itemize}

We choose the highest score, which in this case is a diagonal move representing a match. It follows intuition: we are now aligning
\verb|G| and \verb|G|, matching them seems logical.

\begin{verbatim}
          G  C  A  T  G
       0 -1 -2 -3 -4 -5
    G -1  1
    A -2
    T -3
    T -4
    A -5
\end{verbatim}

Now let us look at the cell in the \verb|C| column and the \verb|G| row. Moving from the top yields -3, moving from the left yields
0 and moving diagonally yields -2, as it is a mismatch in this case. The highest of these scores is 0.

\begin{verbatim}
          G  C  A  T  G
       0 -1 -2 -3 -4 -5
    G -1  1  0
    A -2
    T -3
    T -4
    A -5
\end{verbatim}

We continue filling out the table this way until it is complete.

\begin{verbatim}
          G  C  A  T  G
       0 -1 -2 -3 -4 -5
    G -1  1  0 -1 -2 -3
    A -2  0  0  1  0 -1
    T -3 -1 -1  0  2  1
    T -4 -2 -2 -1  1  1
    A -5 -3 -3 -1  0  0
\end{verbatim}

As we have now calculated the scores for all prefixes, we can use backtracking to find the optimal alignment for the two sequences.
Starting in the bottom right cell, we choose the cell (top, left or top-left) with the highest score. If multiple cells have the same score, we can 
choose either. The different alignments the cells represent are all optimal. The cell that we choose gives us the optimal alignment
of the sequences before the last character was added. Depending on the direction by which we moved, we know whether this last character
was a character of the sequence or a gap.

For example, consider the bottom right corner of the matrix.

\begin{verbatim}
       T  G
    T  1  1
    A  0  0
\end{verbatim}

Starting in the bottom right, we can choose either the top or the top-left cell. Choosing the top-left one, i.e. moving diagonally, means that
the last characters in the alignment were \verb|A| and \verb|G| for the respective sequences. We can find the alignment of the prefixes \verb|GATT|
and \verb|GCAT| by backtracking from the top-left cell. By contrast, choosing the top cell means inserting a gap in the second sequence, and by backtracking
from there we can find the alignment of \verb|GATT| and \verb|GCATG|.

\begin{figure}[h]
    \begin{equation*}
        \begin{matrix}
                &            & G          & C          & A          & T          & G        \\
                & \rn{00}{0} & -1         & -2         & -3         & -4         & -5       \\
            G   & -1         & \rn{11}{1} & 0          & -1         & -2         & -3       \\
            A   & -2         & 0          & \rn{22}{0} & \rn{23}{1} & 0          & -1       \\
            T   & -3         & -1         & -1         & 0          & \rn{34}{2} & 1        \\
            T   & -4         & -2         & -2         & -1         & \rn{44}{1} & 1        \\
            A   & -5         & -3         & 3          & -1         & 0          & \rn{55}{0}
        \end{matrix}
    \end{equation*}

    \begin{tikzpicture}[overlay,remember picture]
        \draw [->] (55) -- (44);
        \draw [->] (44) -- (34);
        \draw [->] (34) -- (23);
        \draw [->] (23) -- (22);
        \draw [->] (22) -- (11);
        \draw [->] (11) -- (00);
    \end{tikzpicture}
\caption{A path representing an optimal alignment.}
\label{alignment_path}
\end{figure}


Figure \ref{alignment_path} shows a path that represents the alignment

\begin{verbatim}
    G A - T T A
    G C A T - G
\end{verbatim}

\subsubsection{Smith-Waterman algorithm}

\emph{This section is based on \cite{smith_waterman}.}

The algorithm is similar to Needleman-Wunsch algorithm. As its purpose is to find an optimal local alignment, it does not
penalize long regions of mismatches or gaps. Its purpose is to find regions with the most matches. The only difference from the Needle\-man-Wunsch 
algorithm is in how new matrix cells are filled out. Namely, when willing out a new cell, we use the formula

\[ M_{i, j} = max
    \begin{cases}
        0   \\
        M_{i-1, j-1} + s(A_{i-1}, B_{j-1}) \\
        M_{i-1, j} + s(A_{i-1}, \sigma)    \\
        M_{i, j-1} + s(\sigma, B_{j-1})
    \end{cases}
\]

In other words, all negative values in what would be the matrix from Needle\-man-Wunsch algorithm are replaced by 0.

\subsection{Multiple sequence alignment: progressive methods}

As has already been mentioned, it is essentially impossible to use dynamic programming to compute the alignment of more than two sequences.
Therefore, other methods have been developed. The most successful ones appear to be the so-called progressive methods. In general,
they use some heuristics to estimate a guide tree, which is a phylogenetic tree determining how close the sequences are to each other,
and then they compute the actual multiple alignment following the order of this tree.

One of such methods is the Tree-based Consistency Objective Function for alignment Evaluation (T-Coffee) algorithm \citep{t_coffee}.
Its most important contribution is its extended library generated from both local and global pairwise alignments of all pairs of input sequences.
This library enables the algorithm to make fewer mistakes in the initial stages of the guide tree, as these errors propagate throughout the entire tree.
Figure \ref{fig:msa_mistakes} shows how a word can become misaligned using other progressive approaches.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{t-coffee-errors}
\caption{Misalignment of the word CAT using other progressive methods. \citep[Figure~2(a)]{t_coffee}}
\label{fig:msa_mistakes}
\end{figure}

Another method is MAFFT (the name presumably coming from the acronyms for multiple alignment and fast Fourier transform) \citep{mafft}.
The authors focused on finding alignments that are not only optimal, but also biologically correct. They developed a way of rapid identification
of homologous regions between two sequences using FFT, and then used the better pairwise alignments to create a better multiple alignment.

\subsubsection{T-Coffee}

\emph{This section is based on \cite{t_coffee}.}

The T-Coffee algorithm consists of various stages. The first one is to compute pairwise alignments for all pairs of input sequences.
Two primary libraries are generated, one for global and one for local alignments. Each can contain more than one alignment for each pair.

As some alignments tend to be more correct than others, weighting is then performed. The authors chose sequence identity of two aligned
sequences as the weight of each of the aligned residues in the pair. For example, consider the sequences $A$ \verb|GARFIELD THE LAST FAT CAT|
and $B$ \verb|GARFIELD THE FAST CAT|. If they are aligned as

\begin{verbatim}
    GARFIELD THE LAST FAT CAT
    GARFIELD THE FAST CAT ---
\end{verbatim}

then their sequence identity is 88\%, as there are two non-equal characters aligned (i.e. there is no gap penalty). Therefore, the weight of
each residue pair $W(A(x), B(y))$, where $A(x)$ denotes the character $x$ from sequence $A$, and analogically for $B(y)$, is equal to 88.
An example of primary library created from pairwise alignments is shown in Figure \ref{fig:primary_lib}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{t-coffee-primary-lib}
\caption{Primary library created from 4 sequences. \citep[Figure~2(b)]{t_coffee}}
\label{fig:primary_lib}
\end{figure}

The two primary libraries are then combined into one by combining all identical residue pairs into one entry and summing their weights, while
pairs that are only present once are added with their original weight. Residue pairs that are not present in any alignment have an implicit weight
of 0.

Although the information present in the primary library is sufficient to obtain a multiple alignment, it is computationally hard to do so. Instead,
the authors chose to generate what they call an extended library using the weights in the primary library.

Library extension is performed by comparing each aligned residue pair with all the others. Consider a residue pair $(A(x), B(y))$ and a sequence $C$.
The initial weight of the pair is then increased by $min(W(A(x), C(z)), W(C(z), B(y)))$, i.e. the minimum weight associated to the alignment of some
residue $C(z)$ with both $A(x)$ and $B(y)$. This is done for all residues from all sequences. In practice, most of the weights will be 0, therefore 
the actual algorithm computes the weights more efficiently. Library extension in effect computes how consistent a residue-pair alignment is.
Figure \ref{fig:extended_lib} shows the computation of extended library.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{t-coffee-extended-lib}
\caption{Extended library weights for two sequences and their alignment recomputed using these weights. \citep[Figure~2(c)]{t_coffee}}
\label{fig:extended_lib}
\end{figure}

Having obtained the consistency information from the extended library, it is now possible to create the guide tree and the final multiple alignment.
Using a distance matrix between all the sequences, the tree is computed as follows. First, we align the closest two sequences using dynamic programming
and the weights from the extended library. In each of the following steps, we either add a sequence to an already computed alignment, or we align
the next closest sequences. We repeat this step until the alignment of all sequences is complete.

Figure \ref{fig:t_coffee} shows the layout of the T-Coffee algorithm.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{t-coffee-flowchart}
\caption{T-Coffee layout. \citep[Figure~1]{t_coffee}}
\label{fig:t_coffee}
\end{figure}

\subsubsection{MAFFT}

\emph{This section is based on \cite{mafft}.}

The MAFFT method is similar to T-Coffee in that it constructs a library of alignments which it then uses to create the final multiple alignment. The authors developed MAFFT
to work in multiple modes, one of which is the progressive method as described above; the other one is the iterative refinement method, which allows for alterations
of the multiple alignment obtained from the progressive method.

Pairwise alignment in MAFFT uses the fact that certain amino acids have more similar physico-chemical properties than others. Substitutions tend to preserve the
overall structrure of a protein, therefore substitutions of similar amino acids are more frequent than those of different ones. The two properties
the authors use are amino acid volume and polarity.

Let us define the correlation of the volume component between two amino acid sequences with the positional lag of $k$ as

\[
    c_v(k) = \sum_{1\leq n \leq N, 1 \leq n+k \leq M} \hat{v}_1(n) \hat{v}_2(n+k)
\]
where $N$ and $M$ are the lengths of the sequences and $\hat{v}(a) = [v(a) - \bar{v}] / \sigma_v$ is the normalized volume value with $\bar{v}$
denoting the average volume of all the amino acids and $\sigma_v$ their standard deviation.

Since the sequences tend to be equal in length, computing $c_v(k)$ using naive methods takes time proportional to $N^2$. However, applying Fast Fourier
transform to the calculation reduces the time to $\mathcal{O}(N log N)$.

We define the polarity component correlation $c_p(k)$ analogically.

The correlation between two amino acids is then expressed as 

\[
    c(k) = c_v(k) + c_p(k)
\]

\begin{figure}[h]
\centering
\includegraphics{mafft_correlation_plot}
\caption{Plot of the correlation function $c(k)$. \citep[Figure~1A]{mafft}}
\label{fig:mafft1}
\end{figure}

If we plot the function $c(k)$, there will be some peaks corresponding to the homologous regions of the two sequences, if there are any (Figure \ref{fig:mafft1}). However, the FFT
analysis only gives us the positional lag of the regions, not their positions. To find the exact positions, we use a sliding window (of size 30 in the article), shown in Figure \ref{fig:mafft2},
and calculate the degree of local homologies for the 20 highest peaks in the $c(k)$ function. If a segment exceeding a given homology threshold is identified,
we label it as a homologous region.

\begin{figure}[h]
\centering
\includegraphics{mafft_sliding_window}
\caption{Finding homologous regions with different positional lags using a sliding window. \citep[Figure~1B]{mafft}}
\label{fig:mafft2}
\end{figure}

After finding homologous segments between two sequences, their alignment is obtained by constructing a homology matrix $S \in R^{n*n}$, where $n$ is the number of homologous
segments. The cell $S_{ij}$ is assigned a value depending on whether the $i$-th homologous segments of the first sequence corresponds to the $j$-th homologous segment
of the second sequence. If so, the cell gets a value corresponding to the score of this segment; otherwise it has a value of 0. The optimal arrangment of homologous segments
is then obtained using dynamic programming (see Figure \ref{fig:mafft3}).

\begin{figure}[h]
\centering
\includegraphics{mafft_optimal_path}
\caption{Dynamic programming applied to segment arrangement. \citep[Figure~2A]{mafft}}
\label{fig:mafft3}
\end{figure}

Having arranged homologous segments, the algorithm then computes pairwise alignments for each pair of sequences. As in T-Coffee, it uses the alignments to create
the primary and extended libraries, which are in turn used to estimate the guide tree and the final alignment. If MAFFT is configured to perform the progressive 
method, this alignment is the final one. Otherwise, if iterative refinement is allowed, MAFFT uses the weights from the library to adjust the alignment to get a more
optimal one. However, iterative refinement is very slow from a relatively low number of sequences, therefore it is not suitable for a large dataset.

\section{Sequence alignment for chant melodies}
\label{section:chant_alignment}

As we have discussed before, melodies of Gregorian chant are in many ways similar to biological sequences. The alphabet is different (instead of 20 amino acids
in proteins or 4 nucleotide bases in DNA we have around 40 different characters used in melody representation) and the chants are usually shorter in length.
The evolution of both biological and melodic sequences is guided by environmental factors such as migration to other places. Some segments tend to undergo a lot
of modifications, while other remain relatively unchanged. Studying the alignment of chant melodies can reveal a lot of information about their relationship.

An important aspect to consider is that unlike in bioinformatics, here we are working with two closely related sequences - the melody and the text. They cannot
be separated, as they always developed concurrently. Additionally, textual boundaries are important for the segmentation of melodies \citep{chant21}. Here, we
do not treat boundary symbols as special characters. However, in the future, it is worth studying whether they should be treated as such.

In the following sections, we describe three approaches to melody alignment used in our application: word-based alignment, alignment on pitches, and alignment on
intervals. They all come with their pros and cons. Word-based alignment is a fast method that can provide insight into how the tradition changed over time.
It reveals how the length and complexity of otherwise similar chants evolved. Alignment on pitches compares the absolute pitch of chants. It can help identify
contrafacta (chants with the same melody but different texts), which was a difficult task until now. However, this approach is unable to identify similar chants
differing only by a fixed interval (transposition). Alignment on intervals compares the interval differences between subsequent notes. It is useful for identifying
transpositions. However, chants with different notes in a few positions but otherwise identical will be evaluated as dissimilar.

\subsection{Word-based alignment}

The word-based approach serves as a basic tool to show the relationship between the text setting and melody. It is meant primarily for comparing melodies of
the same or similar text, such as chants belonging to the same liturgical position. It can reveal how the complexity of chants evolved over time.
The algorithm aligns the syllables of all chants in such a way that the syllables in the same position are in one column. Thanks to this, the differences
in complexity are clearly visible.

The alignment is computed using Algorithm \ref{algo:align_word}. Its results can be seen in Figure \ref{fig:align_word}.\newline

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{set of volpiano-encoded melodies $V = \{V_1, \dots, V_k\}$, $V_i$ is composed of $w_i$ words $V_i = \{W_{i1}, \dots, W_{iw_i}\}$, $W_{ij}$ is composed of $s_{ij}$ syllables $W_{ij} = \{S_{ij1}, \dots, S_{ijs_{ij}}\}$;
            set of texts $T = \{T_1, \dots, T_k\}$, $T_i$ is composed of $w_i$ words $T_i = \{U_{i1}, \dots, U_{iw_i}\}$, $U_{ij}$ is composed of $r_{ij}$ syllables $U_{ij} = \{R_{ij1}, \dots, R_{ijr_{ij}}\}$}
    \Output{Aligned set of melodies $V^* = \{V^*_1, \dots, V^*_k\}$, $V^*_i$ is composed of $w$ words $V^*_i = \{W^*_{i1}, \dots, W^*_{iw}\}$, $W^*_{ij}$ is composed of $s_j$ syllables $W^*_{ij} = \{S^*_{ij1}, \dots, S^*_{ijs_j}\}$;
            and their texts $T^* = \{T^*_1, \dots, T^*_k\}$, $T^*_i$ is composed of $w$ words $T^*_i = \{U^*_1, \dots, U^*_{iw}\}$, $U^*_{ij}$ is composed of $s_j$ syllables $U^*_{ij} = \{R^*_{ij1}, \dots, R^*_{ijs_j}\}$}
    \BlankLine
    $w \longleftarrow \max_i w_i$\;
    initialize each $V^*_i$ and $T^*_i$ to be of length $w$\;
    \For{$j \in \{1, \dots, w\}$}{
        $s_j \longleftarrow \max_i s_{ij}$\;
        set each $W^*_{ij}$ and $U^*_{ij}$ to be of length $s_j$\;
    }
    \For{$i \in \{1, \dots, k\}$}{
        \For{$j \in \{1, \dots, w_i\}$}{
            \For{$m \in \{1, \dots, s_{ij}\}$}{
                $S^*_{ijm} = S_{ijm}$\;
                \uIf{$s_{ij} < r_{ij}$}{
                    \eIf{$m = s_{ij}$}{
                        $R^*_{ijm} = concat(R_{ijm}, \dots, R_{ijr_{ij}})$\;
                    }{
                        $R^*_{ijm} = R_{ijm}$\;
                    }
                }\uElseIf{$s_{ij} > r_{ij}$}{
                    \eIf{$m > r_{ij}$}{
                        $R^*_{ijm} = ""$\;
                    }{
                        $R^*_{ijm} = R_{ijm}$\;
                    }
                }\uElse{
                    $R^*_{ijm} = R_{ijm}$\;
                }
            }
        }
    }
    return $V*$, $T*$\;
    \caption{Naive approach to alignment}
    \label{algo:align_word}
\end{algorithm}

\begin{figure}[h]
\centering
\includegraphics[scale=0.35]{alignment_naive}
\caption{Chants of different genres aligned using the naive approach. The vertical lines represent word boundaries.}
\label{fig:align_word}
\end{figure}

\subsection{Melody preprocessing}
\label{section:vol_preprocess}

The alignment software uses the character \verb|-| for marking gaps,
it requires that the input sequences do not contain any, or they will be removed. Since melodies encoded as Volpiano use the character to mark ends of words
and ends of syllables, we need to perform some preprocessing. Namely, we replace all contiguous sequences \verb|---| with the end-of-word marking symbol \verb|~|
and all contiguous sequences \verb|--| with the end-of-syllable marker \verb=|=. All remaining \verb|-|s are removed, if there are any.

\subsection{Multiple alignment using absolute pitches}

For this task, we are using the MAFFT software\footnote{\url{https://mafft.cbrc.jp/alignment/software/}}.
MAFFT primarily works for sequences of amino acids and nucleotide bases, but it also has a limited support for non-biological sequences.

After we process the sequences as described in Section \ref{section:vol_preprocess}, they are passed to MAFFT with the option \verb|--text|, which
indicates that the sequences are not biological. Additionally, we also pass the option \verb|--reorder|, which returns the aligned sequences in order 
of similarity. We made this choice so as to facilitate the identification of related melodies.

After MAFFT performs the alignment, we retrieve the sequences and attempt to combine them with their text.
We do this by splitting both the text and the melody into syllables and mapping them onto each other (Algorithm \ref{algo:volpiano_text_combine}). 
However, this might not be possible. Due to errors in the original encoded melody (i.e. a missing or an extra \verb|-|),
we may have altered the structure of the chant in preprocessing. In case of such an event, we remove the affected sequence from consideration and align the remaining
sequences again.

The process is described in Algorithm \ref{algo:align_pitch}. Its results are shown in Figure \ref{fig:align_pitches}.\newline

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{volpiano-encoded melody $V$, $V$ is composed of $w$ words $V = \{W_1, \dots, W_w\}$, $W_i$ is composed of $s_i$ syllables $W_i = \{S_{i1}, \dots, S_{is_i}\}$;
            text $T$, $T$ is composed of $w$ words $T = \{U_1, \dots, U_w\}$, $U_i$ is composed of $r_i$ syllables $U_i = \{R_{i1}, \dots, R_{ir_i}\}$}
    \Output{text $T*$ modified to match the melody; $T*$ is composed of $w$ words $T^* = \{U^*_1, \dots, U^*_w\}$, $U^*_i$ is composed of $s_i$ syllables $U^*_i = \{R^*_{i1}, \dots, R^*_{is_i}\}$}
    \BlankLine
    \For{$i \in \{1, \dots, w\}$}{
        \uIf{$s_i < r_i$}{
            $R^*_{ij} = R_{ij} \forall j \in \{1, \dots, s_i - 1\}$\;
            $R^*_{is_i} = concat(R_{is_i}, \dots, R_{ir_i})$\;
        }
        \uElseIf{$s_i > r_i$}{
            $R^*_{ij} = R_{ij} \forall j \in \{1, \dots, r_i\}$\;
            $R^*_{ij} = "" \: \forall j \in \{r_i + 1, \dots, s_i\}$\;
        }
        \uElse{
            $R^*_{ij} = R_{ij} \forall j \in \{1, \dots, s_i\}$\;
        }
    }
    return $T^*$\;
    \caption{Aligning melody and text}
    \label{algo:volpiano_text_combine}
\end{algorithm}

Once all sequences are successfully aligned without errors in text and melody combination, we can display them to the user. In the application, we use the Volpiano font,
so as to maintain consistency. However, the sequences shown are not properly encoded following Volpiano protocols. First of all, we choose different representations of end of a word
(here we use a bar line) and end of a syllable (a single space) so that the number of characters in each sequence remains equal and the alignment is visible. Second of all,
after the alignment, MAFFT will have inserted \verb|-|s to represent gaps. In proper Volpiano, these characters represent gaps between words, syllables, and neumes. However,
here they just mean empty space.\newline

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{a set of volpiano-encoded melodies $V$ with their respective texts $T$}
    \Output{aligned melodies $V^*$ and their texts $T^*$}
    \BlankLine
    $\hat{V} \longleftarrow V$ preprocessed to a MAFFT-friendly format\;
    $aligned\_without\_errors \longleftarrow False$\;
    \While{not $aligned\_without\_errors$}{
        $aligned\_without\_errors \longleftarrow True$\;
        $V^* \longleftarrow$ result after running $\hat{V}$ through MAFFT\;
        \For{$V^*_i \in V^*$}{
            $T^*_i \longleftarrow $ result of algorithm \ref{algo:volpiano_text_combine} on $V^*_i$ and $T_i$\;
            \If{$T^*_i$ cannot be calculated}{
                $\hat{V} \longleftarrow \hat{V}\setminus\{\hat{V}_i\}$\;
                $aligned\_without\_errors \longleftarrow False$\;
            } 
        }
    }
    return $V^*$ and $T^*$\;
    \caption{Multiple alignment using absolute pitches}
    \label{algo:align_pitch}
\end{algorithm}

\begin{figure}[h]
\centering
\includegraphics[scale=0.35]{alignment_pitches}
\caption{Chants aligned using MAFFT on absolute pitches.}
\label{fig:align_pitches}
\end{figure}

\subsection{Multiple alignment using intervals}

The general outline of the algorithm is the same as Algorithm \ref{algo:align_pitch}. However, as we are not aligning absolute pitches, but rather intervals,
we need to compute these intervals.

There are 18 possible pitches, which means 37 possible intervals (17 positive, 17 negative, and one without the change of pitch). We will represent the no-change interval
with the character \verb|a|, the positive intervals with the lowercase characters \verb|b-t| and the negative intervals with the uppercase characters \verb|B-T|. The characters
\verb|i| and \verb|I| are not used for reasons explained later.

The interval representation is constructed from a Volpiano-encoded melody by replacing the note symbols with the appropriate interval symbol. The $i$-th note will be
replaced with the symbol representing the interval $(i-1, i)$. As the first note has no predecessor, it is left as it is. The non-note symbols also remain unchanged.
Algorithm \ref{algo:convert_to_interval} shows how the interval representation is constructed.\newline

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{volpiano-encoded melody $V = v_1v_2\dots v_m$, note symbols $N$, interval symbols $J$, $J_{ab}$ is the symbol representing the interval $(a, b)$}
    \Output{interval representation of the input melody $I = i_1i_2\dots i_m$}
    \BlankLine
    \For{$k \in \{1, \dots, m\}$}{
        \uIf{$v_k \notin N$}{
            $i_k \longleftarrow v_k$\;
        }
        \uElseIf{$v_k \in N \land v_l \notin N \: \forall l < k$}{
            $i_k \longleftarrow v_k$\;
            $last\_seen\_note \longleftarrow v_k$\;
        }
        \uElse{
            $i_k \longleftarrow J_{last\_seen\_note, v_k}$\;
            $last\_seen\_note \longleftarrow v_k$\;
        }
    }
    return $I$\;
    \caption{Converting volpiano-encoded melody into interval representation}
    \label{algo:convert_to_interval}
\end{algorithm}

We use the interval representations as inputs to MAFFT. That means that what MAFFT returns are the aligned sequences of intervals. To display them to the user
properly, we need to decode the sequences. Algorithm \ref{algo:decode_interval} shows how to do this.\newline

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Output{interval representation of a melody $I = i_1i_2\dots i_m$, note symbols $N$, interval symbols $J$, $J_{ab}$ is the symbol representing the interval $(a, b)$}
    \Input{volpiano-encoded equivalent of the input melody $V = v_1v_2\dots v_m$}
    \BlankLine
    \For{$k \in \{1, \dots, m\}$}{
        \uIf{$i_k \in N \land i_l \notin N \: \forall l < k$}{
            $v_k \longleftarrow i_k$\;
            $last\_seen\_note \longleftarrow i_k$\;
        }
        \uElseIf{$i_k \in J \land \exists l: i_l < k \land i_l \in N$}{
            $v_k \longleftarrow a, s.t. \: J_{last\_seen\_note,a} = i_k$\;
            $last\_seen\_note \longleftarrow v_k$\;
        }
        \uElse{
            $v_k \longleftarrow i_k$\;
        }
    }
    return $V$\;
    \caption{Converting interval representation back to volpiano}
    \label{algo:decode_interval}
\end{algorithm}

The reason why \verb|i| and \verb|I| do not represent any interval is that they represent non-note symbols (flat and natural signs). If we used the characters for intervals,
it would be problematic to convert an interval representation to Volpiano encoding. As we are looking at whether a character is a note or an interval or neither, 
if they represented an interval, we would choose the appropriate (interval) branch in Algorithm \ref{algo:decode_interval}. However, if they had originally represented
a non-note symbol, we would mistakenly shift the rest of the melody by an interval. 

The complete algorithm to calculate the interval alignment is shown in Algorithm \ref{algo:align_intervals}, similar to Algorithm \ref{algo:align_pitch}, and its results
are shown in Figure \ref{fig:align_intervals}.\newline

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
    \Input{a set of $n$ volpiano-encoded melodies $V$ with their respective texts $T$}
    \Output{aligned melodies $V^*$ and their texts $T^*$}
    \BlankLine
    $I_i \longleftarrow V_i$ converted using algorithm \ref{algo:convert_to_interval} $\forall i \in \{1,\dots, n\}$\;
    $\hat{I} \longleftarrow I$ preprocessed to a MAFFT-friendly format\;
    $aligned\_without\_errors \longleftarrow False$\;
    \While{not $aligned\_without\_errors$}{
        $aligned\_without\_errors \longleftarrow True$\;
        $I^* \longleftarrow$ result after running $\hat{I}$ through MAFFT\;
        $V^*_i \longleftarrow I^*_i$ converted using algorithm \ref{algo:decode_interval} $\forall i \in \{1,\dots, n\}$\;
        \For{$V^*_i \in V^*$}{
            $T^*_i \longleftarrow $ result of algorithm \ref{algo:volpiano_text_combine} on $V^*_i$ and $T_i$\;
            \If{$T^*_i$ cannot be calculated}{
                $\hat{I} \longleftarrow \hat{I}\setminus\{\hat{I}_i\}$\;
                $aligned\_without\_errors \longleftarrow False$\;
            } 
        }
    }
    return $V^*$ and $T^*$\;
    \caption{Multiple alignment using intervals}
    \label{algo:align_intervals}
\end{algorithm}

\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{alignment_intervals}
\caption{Chants aligned using MAFFT on intervals.}
\label{fig:align_intervals}
\end{figure}

\section{Conservation profile}

Having obtained the alignment of chants, we can borrow other bioinformatics concepts to calculate interesting characteristics. One example is \emph{conservation profile}.
Given a set of aligned sequences $A = \{A_1,\dots,A_n\}$, $A_i = a_{i1}a_{i2}\dots a_{ik}$, we define the conservation value of element $A_{ij}$ as

\[
    con(A_{ij}) = \frac{\sum^n_{l=1} \mathbbm{1}[A_{lj} = a_{ij}]}{|A|}
\]
In other words, the conservation value gives the proportion of the symbol $a_{ij}$ at position $j$ over all sequences.

Conservation profile is then the vector $C$ whose elements $C_j$ are defined as

\[
    C_j = \frac{\sum^n_{i=1}con(A_{ij})}{|A|}
\]

Our application does not visualize conservation profile, but rather the conservation values of all meaningful symbols (i.e. those that represent notes or intervals). It
also computes the average conservation value $\frac{\sum^k_{j=1} C_j}{k}$.

Conservation profile of aligned sequences depends on what approach we choo\-se. Consider the last two chants shown in Figure \ref{fig:align_intervals}. Each note
is different, however, a person well-versed in musical theory immediately notices that they are only shifted by 5 semitones (except for the first note). If we consider only
the intervals, they are almost the same melodies. However, if we consider the absolute pitches, they are totally different. Figure \ref{fig:cons_pitch}
and Figure \ref{fig:cons_intervals} demonstrate these differences by displaying the chants' conservation profile.

\begin{figure}[h]
\centering
\includegraphics{alignment_antiphons_pitches}
\caption{Conservation profile on chants aligned by pitch.}
\label{fig:cons_pitch}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics{alignment_antiphons_intervals}
\caption{Conservation profile on chants aligned by intervals.}
\label{fig:cons_intervals}
\end{figure}
